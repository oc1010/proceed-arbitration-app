import streamlit as st
from docxtpl import DocxTemplate
from io import BytesIO
from datetime import date, timedelta
import pandas as pd
from db import load_responses, save_complex_data

st.set_page_config(page_title="Drafting Engine", layout="wide")

if st.session_state.get('user_role') != 'arbitrator':
    st.error("Access Denied. Only the Arbitrator can draft PO1.")
    st.stop()

# --- 1. LOAD DATA ---
p1 = load_responses("phase1")
p2 = load_responses("phase2")
claimant = p2.get('claimant', {})
respondent = p2.get('respondent', {})
c_p1 = p1.get('claimant', {})

# --- 2. WIDGET HELPERS ---
def decision_widget(label, var_name, key_in_db, clause_map=None, default_text="", help_note=""):
    """
    Comparison Widget: Shows Parties' preferences and lets Arbitrator decide.
    Returns: The final text string for the document.
    """
    with st.container():
        c_top, c_chk = st.columns([4, 1])
        c_top.markdown(f"**{label}**")
        
        # Checkbox to include/exclude the clause from PO1
        is_included = c_chk.checkbox("Include?", value=True, key=f"chk_{var_name}", help=f"Uncheck to remove '{label}'")
        if not is_included:
            st.divider()
            return ""

        if help_note: st.caption(help_note)
        
        c_ans = claimant.get(key_in_db, "Pending")
        r_ans = respondent.get(key_in_db, "Pending")
        
        cols = st.columns([1, 1, 2])
        with cols[0]:
            st.info(f"üë§ **Claimant:**\n{c_ans}")
        with cols[1]:
            st.warning(f"üë§ **Respondent:**\n{r_ans}")
        
        # Determine Default Logic
        c_text = clause_map.get(c_ans, c_ans) if clause_map else c_ans
        final_default = default_text if default_text else c_text

        with cols[2]:
            val = st.text_area(f"Final Clause ({label})", value=final_default, key=f"in_{var_name}", height=100)
        
        st.divider()
        return val

# --- 3. CLAUSE LIBRARIES ---
# These maps convert short questionnaire answers into full legal paragraphs.
PROCEED_PROTOCOL = """The Parties and the Arbitral Tribunal shall use the secure electronic case management platform PROCEED (the ‚ÄúPlatform‚Äù) as the primary administrative engine.
The procedural timetable maintained on the Platform‚Äôs ‚ÄòSmart Timeline‚Äô module shall constitute the official procedural record.
Automatic notifications generated by the Platform shall constitute valid administrative notice.
To strictly preserve confidentiality, Parties shall not upload unredacted sensitive commercial documents to the Platform unless encrypted."""

EMAIL_PROTOCOL = """The Parties shall conduct case management via email. 
Filings shall be submitted in PDF format via email to the Tribunal and the opposing Party."""

LIB = {
    "bifurcation": {
        "Option A: Single Phase.": "The Tribunal shall hear all issues (Jurisdiction, Liability, and Quantum) together in a single phase.",
        "Option B: Bifurcation Requested.": "Pursuant to LCIA Article 22.1(vii), the proceedings are bifurcated. Phase 1 shall address Liability only."
    },
    "style": {
        "Option A: Memorial Style.": "The Parties shall submit their written submissions in accordance with the Memorial Style. This shall involve the simultaneous exchange of a Statement of Claim and Statement of Defence, each accompanied by all factual evidence (witness statements) and expert reports relied upon.",
        "Option B: Pleading Style.": "The Parties shall submit their written submissions in accordance with the Pleading Style. Factual allegations and legal arguments shall be submitted first, with Witness Statements and Expert Reports exchanged only after the Document Production phase."
    },
    "doc_prod_rules": {
        "Option A: IBA Rules (Binding).": "The Tribunal shall be bound by the IBA Rules on the Taking of Evidence (2020).",
        "Option B: IBA Rules (Guidelines).": "The Tribunal shall be guided by the IBA Rules on the Taking of Evidence (2020).",
        "Option C: No specific guidelines.": "The Tribunal shall apply the general evidentiary powers under the LCIA Rules."
    },
    "venue": {
        "At Seat": "The Oral Hearing shall be held physically at the Seat of Arbitration.",
        "Neutral Venue": "The Oral Hearing shall be held physically at a neutral venue (IDRC London).",
        "Virtual": "The Oral Hearing shall be held virtually via video conference."
    },
    "cost_alloc": {
        "Option A: Costs follow the event.": "Costs shall be allocated on the principle that 'costs follow the event' (loser pays).",
        "Option B: Apportionment.": "Costs shall be apportioned reflecting the relative success of the Parties on individual issues."
    }
}

# --- 4. APP UI ---
st.title("üìù Procedural Order No. 1 - Drafting Cockpit")

# Initialize Timetable State if not exists
if "timetable_df" not in st.session_state:
    st.session_state.timetable_df = pd.DataFrame([
        {"Step": 1, "Date": date.today() + timedelta(weeks=4), "Party": "Claimant", "Action": "Statement of Case", "Notes": "Incl. Witness Statements"},
        {"Step": 2, "Date": date.today() + timedelta(weeks=8), "Party": "Respondent", "Action": "Statement of Defence", "Notes": "Incl. Witness Statements"},
    ])

# TABS
t1, t2, t3, t4, t5, t6 = st.tabs(["1. General", "2. Timetable Builder", "3. Evidence", "4. Hearing", "5. Costs", "6. Misc"])

ctx = {} # Dictionary to hold final variables for Word

with t1:
    st.header("General & Constitution")
    c1, c2 = st.columns(2)
    ctx['Case_Number'] = c1.text_input("Case Reference", "ARB/24/001")
    ctx['seat_of_arbitration'] = c2.text_input("Seat", "London")
    ctx['meeting_date'] = str(date.today())
    ctx['date_of_order'] = str(date.today())
    ctx['governing_law_of_contract'] = st.text_input("Governing Law", "English Law")
    
    with st.expander("Edit Party & Tribunal Names", expanded=False):
        c3, c4 = st.columns(2)
        ctx['claimant_rep_1'] = c3.text_input("Claimant Rep 1", "Ms. Jane Doe")
        ctx['claimant_rep_2'] = c3.text_input("Claimant Rep 2", "")
        ctx['respondent_rep_1'] = c4.text_input("Respondent Rep 1", "Mr. John Smith")
        ctx['respondent_rep_2'] = c4.text_input("Respondent Rep 2", "")
        # Add basic address placeholders if empty
        ctx['Contact_details_of_Claimant'] = ""
        ctx['Contact_details_of_Respondent'] = ""
        ctx['Contact_details_of_Claimant_Representative'] = ""
        ctx['Contact_details_of_Respondent_Representative'] = ""
        
        t1, t2, t3 = st.columns(3)
        ctx['Contact_details_of_Arbitrator_1'] = t1.text_input("Co-Arb 1", "Dr. A")
        ctx['Contact_details_of_Arbitrator_2'] = t2.text_input("Co-Arb 2", "Ms. B")
        ctx['Contact_details_of_Arbitrator_3_Presiding'] = t3.text_input("Presiding", "Prof. C")

    ctx['bifurcation_decision'] = decision_widget("Bifurcation", "bif", "bifurcation", LIB['bifurcation'])
    ctx['consolidation_decision'] = decision_widget("Consolidation", "con", "consolidation")
    
    sec_clause = decision_widget("Secretary Appointment", "sec", "secretary", 
        {"Option A: Consent.": "The Tribunal appoints a Secretary.", "Option B: Object.": "No Secretary is appointed."})
    ctx['tribunal_secretary_appointment'] = sec_clause
    
    if "No Secretary" not in sec_clause:
        ctx['tribunal_secretary_fees'] = decision_widget("Secretary Fees", "sec_fees", "sec_fees")
    else:
        ctx['tribunal_secretary_fees'] = ""

with t2:
    st.header("üìÖ Sophisticated Timetable Builder")
    st.info("Design the procedural calendar. The table below will be inserted directly into the PO1.")
    
    # A. PRESET GENERATOR
    col_preset, col_act = st.columns([3, 1])
    preset = col_preset.radio("Load Preset Template:", ["Memorial Style (Front Loaded)", "Pleading Style (Sequential)"], horizontal=True)
    
    if col_act.button("üîÑ Apply Preset"):
        base = date.today()
        if "Memorial" in preset:
            data = [
                {"Step": 1, "Date": base + timedelta(weeks=4), "Party": "Claimant", "Action": "Statement of Case", "Notes": "Facts, Law, WS, Experts"},
                {"Step": 2, "Date": base + timedelta(weeks=8), "Party": "Respondent", "Action": "Statement of Defence", "Notes": "Facts, Law, WS, Experts"},
                {"Step": 3, "Date": base + timedelta(weeks=10), "Party": "Both", "Action": "Redfern Requests", "Notes": "Simultaneous exchange"},
                {"Step": 4, "Date": base + timedelta(weeks=12), "Party": "Both", "Action": "Production of Documents", "Notes": "Rolling basis"},
                {"Step": 5, "Date": base + timedelta(weeks=16), "Party": "Claimant", "Action": "Reply Memorial", "Notes": "Responsive evidence only"},
                {"Step": 6, "Date": base + timedelta(weeks=20), "Party": "Respondent", "Action": "Rejoinder Memorial", "Notes": "Responsive evidence only"},
                {"Step": 7, "Date": base + timedelta(weeks=24), "Party": "All", "Action": "Pre-Hearing Conference", "Notes": "Virtual"},
                {"Step": 8, "Date": base + timedelta(weeks=28), "Party": "All", "Action": "Oral Hearing", "Notes": "10 Days reserved"}
            ]
        else:
            data = [
                {"Step": 1, "Date": base + timedelta(weeks=4), "Party": "Claimant", "Action": "Statement of Case", "Notes": "Pleadings only"},
                {"Step": 2, "Date": base + timedelta(weeks=8), "Party": "Respondent", "Action": "Statement of Defence", "Notes": "Pleadings only"},
                {"Step": 3, "Date": base + timedelta(weeks=12), "Party": "Both", "Action": "Document Production", "Notes": "Standard Redfern"},
                {"Step": 4, "Date": base + timedelta(weeks=16), "Party": "Both", "Action": "Exchange of Witness Statements", "Notes": "Simultaneous"},
                {"Step": 5, "Date": base + timedelta(weeks=24), "Party": "All", "Action": "Oral Hearing", "Notes": ""}
            ]
        st.session_state.timetable_df = pd.DataFrame(data)
        st.rerun()

    # B. INTERACTIVE EDITOR
    st.markdown("### ‚úèÔ∏è Edit Schedule")
    edited_df = st.data_editor(
        st.session_state.timetable_df,
        num_rows="dynamic",
        use_container_width=True,
        column_config={
            "Step": st.column_config.NumberColumn(width="small"),
            "Date": st.column_config.DateColumn(format="DD MMM YYYY"),
            "Party": st.column_config.SelectboxColumn(options=["Claimant", "Respondent", "Both", "Tribunal", "All"]),
            "Action": st.column_config.TextColumn(width="large"),
            "Notes": st.column_config.TextColumn(width="medium")
        }
    )
    st.session_state.timetable_df = edited_df
    
    # C. FORMATTING FOR WORD (Text-Table)
    # This creates a clean text block that looks like a list/table in the Word doc
    table_text = ""
    for _, row in edited_df.iterrows():
        d_str = row['Date'].strftime("%d %B %Y") if isinstance(row['Date'], date) else str(row['Date'])
        table_text += f"{row['Step']}. {d_str} | {row['Party']}: {row['Action']} ({row['Notes']})\n"
    
    ctx['procedural_timetable_table'] = table_text
    
    # Mediation Window Logic
    ctx['mediation_window_clause'] = decision_widget("Mediation Window", "med", "mediation")

with t3:
    st.header("Evidence")
    
    # Platform Logic (Matches template {{ platform_usage_clause }})
    plat_choice = claimant.get("platform", "Pending")
    default_plat = PROCEED_PROTOCOL if "PROCEED" in plat_choice else EMAIL_PROTOCOL
    ctx['platform_usage_clause'] = decision_widget("Platform Usage Protocol", "plat", "platform", default_text=default_plat)

    ctx['submission_style_decision'] = decision_widget("Submission Style", "style", "style", LIB['style'])
    ctx['page_limits_decision'] = decision_widget("Page Limits", "pg", "limits_submission")
    ctx['last_submission_definition'] = decision_widget("Last Submission Def.", "last", "last_submission")
    
    st.divider()
    ctx['evidence_rules_decision'] = decision_widget("IBA Rules", "iba", "doc_prod", LIB['doc_prod_rules'])
    ctx['doc_prod_limits_decision'] = decision_widget("Doc Prod Limits", "lim", "limits")
    ctx['privilege_standard_decision'] = decision_widget("Privilege Standard", "priv", "privilege_std")
    ctx['privilege_logs_decision'] = decision_widget("Privilege Logs", "logs", "privilege_logs")
    
    st.subheader("Witnesses & Experts")
    ctx['witness_exam_rule'] = decision_widget("Witness Exam Scope", "wit", "witness_exam")
    ctx['expert_meeting_decision'] = decision_widget("Expert Meetings", "exp_meet", "expert_meeting")
    ctx['expert_hottubing_decision'] = decision_widget("Expert Hot-Tubbing", "exp_tub", "expert_hot_tub")

with t4:
    st.header("Hearing")
    c_p1_val = c_p1.get('p1_hearing', '')
    ctx['hearing_venue_decision'] = decision_widget("Hearing Venue", "venue", "physical_venue_preference", LIB['venue'], help_note=f"Phase 1 Pref: {c_p1_val}")
    
    ctx['chess_clock_decision'] = decision_widget("Chess Clock", "clock", "chess_clock")
    ctx['transcription_decision'] = decision_widget("Transcription", "trans", "transcription")
    ctx['demonstratives_decision'] = decision_widget("Demonstratives", "demo", "demonstratives")
    ctx['interpretation_decision'] = decision_widget("Interpretation", "interp", "interpretation")

with t5:
    st.header("Costs & Award")
    ctx['cost_allocation_decision'] = decision_widget("Cost Principle", "cost", "cost_allocation", LIB['cost_alloc'])
    ctx['counsel_fee_cap_decision'] = decision_widget("Fee Caps", "fees", "counsel_fees")
    
    # FIXED KEYS TO PREVENT DUPLICATES
    ctx['internal_costs_decision'] = decision_widget("Internal Costs", "int_cost", "internal_costs")
    ctx['deposit_structure_decision'] = decision_widget("Deposits", "dep", "deposits")
    
    st.divider()
    ctx['award_currency_decision'] = decision_widget("Currency", "curr", "currency")
    ctx['interest_decision'] = decision_widget("Interest", "interest_rate", "interest")
    ctx['signature_format_decision'] = decision_widget("Signature", "sign", "sign_award")
    ctx['publication_decision'] = decision_widget("Publication", "pub", "publication")

with t6:
    st.header("Misc & Tech")
    ctx['funding_disclosure_clause'] = decision_widget("TPF Disclosure", "fund", "funding")
    ctx['ai_guidelines_clause'] = decision_widget("AI Guidelines", "ai", "ai_guidelines")
    ctx['green_protocols_clause'] = decision_widget("Green Protocols", "green", "sustainability")
    ctx['disability_clause'] = decision_widget("Accessibility", "dis", "disability")
    ctx['gdpr_clause'] = decision_widget("GDPR", "gdpr", "gdpr")
    
    # Fillers for other template variables to avoid errors
    ctx['deadline_timezone'] = "17:00 (Seat of Arbitration)"
    ctx['time_abbreviations'] = "7 days"
    ctx['time_confirm_contact'] = "7 days"
    ctx['time_notify_counsel'] = "immediately"
    ctx['time_shred_docs'] = "6 months"
    ctx['time_notify_oral'] = "45 days"
    ctx['time_appoint_interpreter'] = "14 days"
    ctx['time_submit_exhibits'] = "48 hours"
    ctx['hearing_hours'] = "09:30 to 17:30"
    ctx['schedule_oral_hearing'] = "Standard Agenda"
    ctx['time_hearing_bundle'] = "14 days"
    ctx['time_produce_docs'] = "28 days"
    ctx['max_filename_len'] = "50 characters"
    ctx['prehearing_matters'] = "Logistics, Bundles, and Demonstratives"

# --- GENERATE ---
st.divider()
c_gen, c_sync = st.columns([1, 4])

with c_gen:
    if st.button("üöÄ Generate PO1", type="primary"):
        try:
            doc = DocxTemplate("template_po1.docx")
            doc.render(ctx)
            
            buf = BytesIO()
            doc.save(buf)
            buf.seek(0)
            
            st.download_button("üì• Download PO1", buf, "Procedural_Order_1.docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document")
            st.success("Draft Generated!")
        except Exception as e:
            st.error(f"Template Error: {e}")

with c_sync:
    if st.button("üîÑ Sync Timetable to Phase 4"):
        # Convert df to timeline events for Smart Timeline
        events = []
        for _, row in st.session_state.timetable_df.iterrows():
            events.append({
                "id": f"evt_{row['Step']}",
                "event": row['Action'],
                "current_date": str(row['Date']),
                "owner": row['Party'],
                "status": "Upcoming",
                "logistics": row['Notes']
            })
        save_complex_data("timeline", events)
        st.success(f"Synced {len(events)} events to Smart Timeline.")
